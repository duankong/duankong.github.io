{"pages":[{"title":"","text":"{% raw %} Notouch - About|notouch的博客| var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?05e1e8b7484a08c51cd0953664168cd7\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); Toggle navigation notouch Home archives categories Tags About Notouch About 君子不器 https://notouch.top/ &copy;2018 notouch renderMathInElement(document.body); L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"debug\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/koharu.model.json\"},\"display\":{\"position\":\"left\",\"width\":150,\"height\":300},\"mobile\":{\"show\":true},\"log\":false}); {% endraw %}","link":"/about/index.html"}],"posts":[{"title":"C++基础知识","text":"👺 变量类型C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。 变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。 以下几种基本的变量类型: 类型 描述 bool 存储值 true 或 false char 通常是一个字符（八位），是一个整数类型 int 整数类型 float 单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数 double 双精度浮点值。双精度是1位符号，11位指数，52位小数 void 表示类型的缺失 wchar_t 宽字符类型，双字节类型，在windows下是Unicode 16编码 😿 常量常量是固定值，定义后不能进行修改，程序执行期间不会改变。常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。 在 C++ 中，有两种简单的定义常量的方式： 使用 #define 预处理器。 1#define LENGTH 10 使用 const 关键字。 1const int LENGTH = 10; 💖 字符串✊ C 风格字符串字符串实际上是使用 null 字符 ‘\\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 12char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\\0'};char greeting[] = \"Hello\"; 函数 目的 strcpy(s1, s2) 复制字符串 s2 到字符串 s1。 strcat(s1, s2) 连接字符串 s2 到字符串 s1 的末尾。 strlen(s1) 返回字符串 s1 的长度。 strcmp(s1, s2) 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。 strchr(s1, ch) 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 strstr(s1, s2) 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 ##### 👨‍🎨 C++ 中的 String 类 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main (){ string str1 = \"Hello\"; string str2 = \"World\"; string str3; int len ; // 复制 str1 到 str3 str3 = str1; cout &lt;&lt; \"str3 : \" &lt;&lt; str3 &lt;&lt; endl; // 连接 str1 和 str2 str3 = str1 + str2; cout &lt;&lt; \"str1 + str2 : \" &lt;&lt; str3 &lt;&lt; endl; // 连接后，str3 的总长度 len = str3.size(); cout &lt;&lt; \"str3.size() : \" &lt;&lt; len &lt;&lt; endl; return 0;} 🌳 指针指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。 1234int *ip; /* 一个整型的指针 */double *dp; /* 一个 double 型的指针 */float *fp; /* 一个浮点型的指针 */char *ch; /* 一个字符型的指针 */ 使用指针时会频繁进行以下几个操作： 定义一个指针变量 把变量地址赋值给指针 访问指针变量中可用地址的值 这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。 12345678910111213141516171819202122232425#include &lt;iostream&gt; using namespace std; int main (){ int var = 20; // 实际变量的声明 int *ip; // 指针变量的声明 ip = &amp;var; // 在指针变量中存储 var 的地址 cout &lt;&lt; \"Value of var variable: \"; cout &lt;&lt; var &lt;&lt; endl; // 输出在指针变量中存储的地址 cout &lt;&lt; \"Address stored in ip variable: \"; cout &lt;&lt; ip &lt;&lt; endl; // 访问指针中地址的值 cout &lt;&lt; \"Value of *ip variable: \"; cout &lt;&lt; *ip &lt;&lt; endl; return 0;} 🚵 仿函数仿函数（functors）在C++标准中采用的名称是函数对象（function objects）。仿函数主要用于STL中的算法中，虽然函数指针虽然也可以作为算法的参数，但是函数指针不能满足STL对抽象性的要求，也不能满足软件积木的要求–函数指针无法和STL其他组件搭配，产生更灵活变化。 仿函数本质就是类重载了一个operator()，创建一个行为类似函数的对象。 12345678class Func{ public: void operator() (const string&amp; str) const { cout&lt;&lt;str&lt;&lt;endl; } }; 为什么要使用仿函数呢 ？ 1）仿函数比一般的函数灵活。 2）仿函数有类型识别，可以作为模板参数。 3）执行速度上仿函数比函数和指针要更快的。 🐐 输入输出函数cin、cin.get()、cin.getline()、getline()、gets() 函数 头文件 [空格] [TAB] [回车] 读取内容 cin iostream X X X any 字符串数字，且对于结束符，并不保存到变量中 cin.get() iostream √ √ X char 字符串 cin.getline() iostream √ √ X char 字符串cin.getline(m,5,’a’)’a’为结束符，一般为’\\0’ getline() string √ √ X string getline(cin,s); getchar() string √ √ √ char 单个字符 ch=getchar(); 🔰 函数stod、stof、stoi、stol、stoll、stoul 函数 头文件 描述 stod string Convert string to double stof string Convert string to float stoi string Convert string to integer stol string Convert string to long int stoll string Convert string to long long stoul string Convert string to unsigned integer 🍹 以上。(づ●─●)づ 转载请注明：Duankong的博客 » 点击阅读原文","link":"/2019/10/17/C-基础知识/"},{"title":"C++树的遍历和树状数组","text":"🤷‍ 先序遍历，中序遍历，后序遍历 深度遍历 广度(层次)遍历 🤔 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;vector&gt;#include&lt;queue&gt;#include &lt;set&gt;using namespace std;typedef long long int ll;const int inf = 0x7fffffff;int n;int post[35], pre[35], inor[35];struct node{ int data; node *left_child; node *right_child;};void PreOrder(node *root)//递归{ cout &lt;&lt; root-&gt;data &lt;&lt; ' '; if (root-&gt;left_child!=NULL) { PreOrder(root-&gt;left_child); } if (root-&gt;right_child!=NULL) { PreOrder(root-&gt;right_child); }}void PreOrderLoop(TreeNode *root)//非递归{ std::stack&lt;TreeNode *&gt; s; TreeNode *cur, *top; cur = root; while (cur != NULL || !s.empty()) { while (cur != NULL) { printf(\"%c \", cur-&gt;data); s.push(cur); cur = cur-&gt;left; } top = s.top(); s.pop(); cur = top-&gt;right; }}void InOrder(node *root)//递归{ if (root-&gt;left_child != NULL) { InOrder(root-&gt;left_child); } cout &lt;&lt; root-&gt;data &lt;&lt; ' '; if (root-&gt;right_child != NULL) { InOrder(root-&gt;right_child); }}void InOrderLoop(TreeNode *root)//非递归{ std::stack&lt;TreeNode *&gt; s; TreeNode *cur; cur = root; while (cur != NULL || !s.empty()) { while (cur != NULL) { s.push(cur); cur = cur-&gt;left; } cur = s.top(); s.pop(); printf(\"%c \", cur-&gt;data); cur = cur-&gt;right; }}void PostOrder(node *root)//递归{ if (root-&gt;left_child != NULL) { PostOrder(root-&gt;left_child); } if (root-&gt;right_child != NULL) { PostOrder(root-&gt;right_child); } cout &lt;&lt; root-&gt;data &lt;&lt; ' ';}void PostOrderLoop(TreeNode *root)//非递归{ std::stack&lt;TreeNode *&gt; s; TreeNode *cur, *top, *last = NULL; cur = root; while (cur != NULL || !s.empty()) { while (cur != NULL) { s.push(cur); cur = cur-&gt;left; } top = s.top(); if (top-&gt;right == NULL || top-&gt;right == last){ s.pop(); printf(\"%c \", top-&gt;data); last = top; } else { cur = top-&gt;right; } }}void dfs(node* root)//深度优先遍历（Depth First Search，DFS，主要有三种子方法，前中后序遍历）{ stack&lt;node*&gt; q; q.push(root); node *mynode; while (!q.empty()) { mynode = q.front(); q.pop(); cout &lt;&lt; mynode-&gt;data; num++; if (num &lt; n) cout &lt;&lt; ' '; if (mynode-&gt;right_child != NULL) q.push(mynode-&gt;right_child); if (mynode-&gt;left_child != NULL) q.push(mynode-&gt;left_child); }}int num = 0;void bfs(node* root)//广度优先搜索算法（Breadth First Search）又叫宽度优先搜索，或横向优先搜索{ queue&lt;node*&gt; q; q.push(root); node *mynode; while (!q.empty()) { mynode = q.front(); q.pop(); cout &lt;&lt; mynode-&gt;data; num++; if (num &lt; n) cout &lt;&lt; ' '; if (mynode-&gt;left_child != NULL) q.push(mynode-&gt;left_child); if (mynode-&gt;right_child != NULL) q.push(mynode-&gt;right_child); }}node *Creat_node(int postL, int postR, int inL, int inR){ if (postL&gt;postR) { return NULL; } node *root = new node; root-&gt;data = post[postR]; int i; for ( i = inL; i &lt; inR; i++) { if (inor[i] == post[postR]) break; } int num_left = i - inL;//左子树 root-&gt;left_child = Creat_node(postL, postL + num_left-1, inL, i-1); root-&gt;right_child = Creat_node(postL + num_left, postR - 1, i + 1, inR); return root;}int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; post[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; inor[i]; node* my_node = Creat_node(0, n - 1, 0, n - 1); cout &lt;&lt; \"DFS: \"; dfs(my_node); cout &lt;&lt; endl; cout &lt;&lt; \"BFS: \"; bfs(my_node); cout &lt;&lt; endl; cout &lt;&lt; \"PreOrder: \"; PreOrder(my_node); cout &lt;&lt; endl; cout &lt;&lt; \"InOrder: \"; InOrder(my_node); cout &lt;&lt; endl; cout &lt;&lt; \"PostOrder: \"; PostOrder(my_node); return 0;} 👨‍💻 树状数组12345678910111213141516171819202122232425262728293031323334353637383940int lowbit(int n){ return n&amp;(-n);} void update(int n,int num){ while(n&lt;=MAX) { TreeArray[n]+=num; n+=lowbit(n); }} int GetSum(int n)//前n个元素的和{ int sum=0; while(n&gt;0) { sum+=TreeArray[n]; n-=lowbit(n); } return sum;} int BinarySearch(int target) //二分查找{ int mid; int left = 1, right = MAX_NUM; while (left&lt;=right) { mid = left + (right - left) / 2; if (getsum(mid)&lt;target) left = mid + 1; else right = mid - 1; } cout &lt;&lt; left &lt;&lt; endl;} 🤽‍ 以上。(づ●─●)づ 转载请注明：Duankong的博客 » 点击阅读原文","link":"/2019/10/30/C-树的遍历和树状数组/"},{"title":"Matlab读写超过4GB的图像","text":"💬 Brief introduction to the TIFF formatA TIFF file is, well, a Tagged Image File Format (TIFF). As the name implies, the file itself consists of a whole bunch of ‘tags’ and corresponding values. For example, all TIFF files are expected to have the ImageWidth and ImageLength tags, whose values are the width and length (height) of the image stored within. A core feature of this format lies in how image data is organized in a physical file. TIFF allows for the image data to be stored in chunks as either ‘Tiles’ or ‘Strips’. You could think of a strip as a tile whose width is the same as the image. The format stores offsets for each of these strips or tiles in an image header. This allows for efficient random access of any chunk in the image. The original TIFF format specification calls for use of 32 bit file offset values. I guess you can imagine where I am going with that bit of information. 32 bits implies a maximum value of 2^32 for any offset. Note that these are offsets from the very beginning of the file. In effect, the 32 bit requirement limits the size of the largest possible TIFF file to be under 4 gigabytes. This was fine for a long time (The earliest TIFF release was in 1986), but we now have more data producers hitting this limit. 💦 读取图片 Matlab中imread()支持读取超过4GB的tiff图像。当然也支持LibTIFF自带的读取函数： 函数 Function read 读取整个 TIFF 图像 readEncodedStrip 从指定条带读取数据 readEncodedTile 从指定图块读取数据 💨 写入图片 从LibTIFF版本4.0.0开始，其偏移值格式使用64位而不是32位的，故后面也叫做Bigtiff，理论上最大可以支持17,179,869,184‬GB的图片。 🚵 实现思路Matlab中以 obj.TiffObject = Tiff(obj.Filename, ‘w8’)方式开始写入Bigtiff；然后结合blockproc函数分块写入图像。 🙌 代码实现实现16位灰度图像写入。 🤹‍ 参考Steve on Image Processing and MATLAB构造ImageAdapter类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109 classdef bigTiffWriter &lt; ImageAdapter %BIGTIFFWRITER - A basic image adapter to write Big TIFF files. % % A simple ImageAdapter class implementing a Tiff writer ImageAdapter % object for use with BLOCKPROC. % - Tile dimensions must be multiples of 16. % - Only uint8, RGB input image data is supported. % % Based on \"Working with Data in Unsupported Formats\" % http://www.mathworks.com/help/toolbox/images/f7-12726.html#bse_q4y-1 % % Example: % %% % % Set file names and obtain size information from input file. % inFile = 'example.tif'; % inFileInfo = imfinfo(inFile); % outFile = 'out.tif'; % %% % % Create an output TIFF file with tile size of 128x128 % tileSize = [128, 128]; % has to be a multiple of 16. % outFileWriter = bigTiffWriter(outFile, inFileInfo(1).Height, inFileInfo(1).Width, tileSize(1), tileSize(2)); % %% % % Now call blockproc to rearrange the color channels. % blockproc(inFile, tileSize, @(b) flipdim(b.data,3), 'Destination', outFileWriter); % outFileWriter.close(); % imshowpair(imread(inFile), imread(outFile),'montage'); % % See also: blockproc, Tiff, Tiff/writeEncodedTile % % Copyright 2013 The MathWorks, Inc. properties(GetAccess = public, SetAccess = private) Filename; TiffObject; TileLength; TileWidth; end methods function obj = bigTiffWriter(fname, imageLength, imageWidth, tileLength, tileWidth) % Constructor validateattributes(fname, {'char'}, {'row'}); validateattributes(imageLength, {'numeric'},{'scalar'}); validateattributes(imageWidth, {'numeric'},{'scalar'}); validateattributes(tileLength, {'numeric'},{'scalar'}); validateattributes(tileWidth, {'numeric'},{'scalar'}); if(mod(tileLength,16)~=0 || mod(tileWidth,16)~=0) error('bigTiffWriter:invalidTileSize',... 'Tile size must be a multiple of 16'); end obj.Filename = fname; obj.ImageSize = [imageLength, imageWidth]; obj.TileLength = tileLength; obj.TileWidth = tileWidth; % Create the Tiff object. obj.TiffObject = Tiff(obj.Filename, 'w8'); % Setup the tiff file properties % See \"Exporting Image Data and Metadata to TIFF files % http://www.mathworks.com/help/techdoc/import_export/f5-123068.html#br_c_iz-1 % obj.TiffObject.setTag('ImageLength', obj.ImageSize(1)); obj.TiffObject.setTag('ImageWidth', obj.ImageSize(2)); obj.TiffObject.setTag('TileLength', obj.TileLength); obj.TiffObject.setTag('TileWidth', obj.TileWidth); obj.TiffObject.setTag('Photometric', Tiff.Photometric.MinIsBlack);%图像数据的颜色空间 obj.TiffObject.setTag('BitsPerSample', 16); obj.TiffObject.setTag('SampleFormat', Tiff.SampleFormat.UInt);%像素样本格式 obj.TiffObject.setTag('SamplesPerPixel', 1); obj.TiffObject.setTag('PlanarConfiguration', Tiff.PlanarConfiguration.Chunky); %存储配置 obj.TiffObject.setTag('Compression', Tiff.Compression.LZW); %压缩方式 end function [] = writeRegion(obj, region_start, region_data) % Write a block of data to the tiff file. % Map region_start to a tile number. tile_number = obj.TiffObject.computeTile(region_start); % If region_data is greater than tile size, this function % warns, else it will silently pads with 0s. obj.TiffObject.writeEncodedTile(tile_number, region_data); end function data = readRegion(~,~,~) %#ok&lt;STOUT&gt; % Not . error('bigTiffWriter:noReadSupport',... 'Read support is not implemented.'); end function close(obj) % Close the tiff file obj.TiffObject.close(); end end end 👩‍👩‍👧‍👧 Demo实现 123456inFileInfo = size(img);outFile = img_name;tileSize = [512, 512]; % has to be a multiple of 16.outFileWriter = bigTiffWriter(outFile, inFileInfo(1), inFileInfo(2), tileSize(1), tileSize(2));blockproc(img, tileSize, @(c) c.data, 'Destination', outFileWriter);outFileWriter.close(); 🙆 参考链接LibTIFFbigTiffWriterSteve on Image Processing and MATLAB 🤽‍ 以上。(づ●─●)づ 转载请注明：Duankong的博客 » 点击阅读原文","link":"/2019/10/15/Matlab读写超过4GB的图像/"},{"title":"Learning notes_2018_12","text":"😀 一、梯度、散度、旋度轻松理解散度和旋度 - 数学知识的动画解析 🖐 二、拉格朗日乘子法和KKT条件汽车优化设计 第二章：优化方法的数学基础 王琥 湖南大学 机械与运载工程学院 浅谈最优化问题的KKT条件 【分类战车SVM】第四话：拉格朗日对偶问题（原来这么简单，你也可以轻松学会） 🙎 三、点乘和叉乘$$ a\\cdot b =|a||b|\\cos \\theta$$$$ a\\cdot b =a_1b_1+a_2b_2+ … +a_nb_n $$$$ a \\times b=\\left| \\begin{matrix} i &amp; j &amp; k \\ x_1 &amp; y_1 &amp; z_1 \\ x_2 &amp; y_2 &amp; z_2 \\end{matrix}\\right|=(y_1z_2-y_2z_1)i-(x_1z_2-x_2z_1)j+(x_1y_2+x_2y_1)k$$ 🧚‍ 四、凸集、凸函数 凸集 若某集合中的x和y两个点，若x和y连线之间的所有点（即0&lt;=μ&lt;=1，μx+(1-μ)y）仍属于这个集合，则称此集合为凸集。 直观几何表示： 左边的是凸集，右边的不是凸集，因为右边的集合中任意两点x和y连线之间的所有点有时不属于这个集合（右图中的连线）。 凸函数 对于$x$是定义在某凸集（非空的，空集也被规定为凸集）上的函数，对于凸集中的任意两点$x_1$和$x_2$，若 $$ f[\\mu x_1+(1-\\mu)x_2]\\leq \\mu f(x_1)+(1-\\mu)f(x_2)$$ 则称函数$f(x)$为凸函数。 直观几何表示： 左边的是凸集，右边的不是凸集，因为右边的集合中任意两点x和y连线之间的所有点有时不属于这个集合（右图中的连线）。 也就是说两点对应的函数值$f(x_1)$和$f(x_2)$的之间的连线$(\\mu f(x_1)+(1-\\mu)f(x_2))$大于等于相应的（即同一个$\\mu$值）两点之间连线$(\\mu f(x_1)+(1-\\mu)f(x_2))$对应的函数值$f[\\mu x_1+(1-\\mu)x_2]$ 这其实应叫 下凸。 判定方法可利用定义法、已知结论法以及函数的二阶导数 对于实数集上的凸函数，一般的判别方法是求它的二阶导数，如果其二阶导数在区间上非负，就称为凸函数。(向下凸) 如果其二阶导数在区间上恒大于0，就称为严格凸函数。 👨‍ 五、方程的解若矩阵A的秩为r，即r=R(A) ： 1）若$r=M=N$，则线性方程组$Ax=b$有唯一解； 2）若$r=N&lt; M$,则线性方程组$Ax=b$有唯一解或无解； 3）若$r=M&lt; N$，则线性方程组$Ax=b$有无穷解； 4）若$r&lt; M$,$r&lt; N$，则线性方程组$Ax =b$有无穷解或无解； 🍳 六、正交投影和投影矩阵 正交投影$p$是向量$b$在平面（由矩阵$A$的列向量$a_1$和$a_2$确定）上正交投影 投影矩阵是从向量b变换到其正交投影p过程中的变换矩阵P： 🍻 七、MP和OMPMPOMP 以上。(づ●─●)づ","link":"/2018/11/30/Learning-notes-2018-12/"},{"title":"Learning notes_2018_11","text":"🐯 有关病毒标记 🍧 顺行标记：沿信号传递方向,一般的病毒，常用AAVs 🥧 逆行标记：沿信号传递相反的分向，狂犬病毒，常用Rv 🍻 跨突触标记：多神经元传递 🍥 条件概率、贝叶斯公式和全概率公式🍼 边缘概率(又称先验概率):某个事件发生的概率。 边缘概率 是这样得到的：在联合概率中，把最终结果中那些不需要的事件通过合并成它们的全概率，而消去它们(对离散随机变量用求和得全概率，对连续随机变量用积分得全概率)，这称为边缘化（marginalization），比如A的边缘概率表示为P(A)，B的边缘概率表示为P(B)。 🥜 联合概率表示两个事件共同发生的概率。A与B的联合概率表示为$P ( A \\bigcap B )$或者$P(A,B)$。 🍣 条件概率(又称后验概率):事件A在另外一个事件B已经发生条件下的发生概率。条件概率表示为P(A|B)，读作“在B条件下A的概率”。 条件概率$$P(A|B)=\\frac{P(A,B)}{P(B)}$$ 贝叶斯公式$$ P(A|B)=\\frac{P(B|A)P(A)}{P(B)} $$ 全概率公式$$P(A)=\\sum_{i=1}^n P(A|B_i)P(B_i)$$ 全概率公式和贝叶斯公式的结合$$ P(A|B)=\\frac{P(B|A)P(A)}{\\sum_{i=1}^n P(B|A_i)P(A_i)} $$ 🏋️‍ 无偏估计、有效性、一致性 🚵 无偏估计 估计量的数学期望等于被估计参数的真实值，则称此此估计量为被估计参数的无偏估计，即具有无偏性。 无偏估计的意义是：在多次重复下，它们的平均数接近所估计的参数真值。$$ S^2=\\frac{1}{n-1}\\sum_{i=1}^{n}(X_i-\\overline{X})^2 $$ 🚴‍ 有效性 估计量方差越小，则说明这个估计量有效性更高。 有效性和无偏估计不相关 🎯 一致性 一致性就是在大样本条件下，估计值接近真实值。 🎮 额叶皮层 前额叶指的是额叶的前端。 要了解前额叶的位置，我们应该先了解额叶的位置。大脑的两个半球通常被分为四个脑叶，分别是: 🔩 额叶（Frontal lobe） 🎈 顶叶（Parietallobe） 📄 颞叶（Temporallobe） 📙 枕叶（Occipitallobe） 额叶和顶叶由中央沟（Central sulcus）隔开； 外侧裂（Sylvianfissure）则将颞叶与额叶、顶叶分隔开； 大脑背侧的顶枕沟（Parieto-occipital sulcus）和腹外侧的枕前切迹（Preoccipital notch）则将枕叶与顶叶、颞叶分隔开。 额叶的前端是前额叶，前额叶的表层便是前额叶皮层，主要与人类的高级认知功能相关； 额叶后端的表层是运动皮层，主要与运动的控制相关。 💖 图像的复原方法MATLAB的图像处理工具箱中提供了四种图像复原的函数，分别利用: 维纳滤波器（wiener）复原 规则化滤波器（regularized）复原 Lucy-Richardson方法复原 盲反卷积复原 图像复原的四种函数 函数名 滤波器 deconv 用wnrener滤波器实现图像去模糊 deconvreg 用gularized滤波器实现图像去模糊 deconvlucy 用ucy-Richardson滤波器实现图像去模糊 deconvbind 用反卷积算法实现图像去模糊 其中： deconvwnr函数求得的是最小二乘解 deconvreg 函数求得的是一种约束最下二乘解，在使用此函数时若提供一些关于噪声的参数可以减少去模糊过程中噪声的放大作用。 deconvlucy 函数使用的是一种快速抑制的Lucy-Richardson方法， 经过多次迭代，采用优化技术和泊松统计准则，不需要函数提供模糊图像中关于噪声的额外参数。 使用deconvbind函数时不需要知道真实的点扩散函PSF，使用盲反卷积技术，只需要初始设置一个PSF参数，函数除了返回恢复出的图像外，还返回最后跌倒的点扩散函数PSF。 🕑 朴素贝叶斯算法及贝叶斯估计 定义：贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故统称贝叶斯分类。而贝叶斯分类中最简单的一种：朴素贝叶斯分类。 朴素贝叶斯分类：基于特征条件独立假设，学习输入输出的联合概率分布，对于输入x,朴素贝叶斯法求出后验概率最大的输出y，这等价于期望风险最小化。 朴素贝叶斯法的参数估计：极大似然估计。 贝叶斯估计：用极大似然估计可能出现要估计的概率值为0的情况，这会影响到后验概率的计算结果，使分类产生偏差，解决这类问题的方法是采用贝叶斯估计。 🚩 概念定义🏁 凸集：欧式空间中，对于集合中的任意两点的连线，连线上任意一点都在集合中，我们就说这个集合是凸集。 ➗ 凸函数：对于任意属于[0,1]的a和任意属于凸集的两点x, y，有f( ax + (1-a)y ) &lt;= a * f(x) + (1-a) * f(y)，几何上的直观理解就是两点连线上某点的函数值，大于等于两点之间某点的函数值。凸函数的任一局部极小点也是全局极小点 💭 半正定矩阵：特征值大于等于0的实对称矩阵。 半正定矩阵的充要条件：行列式（n阶顺序主子式）等于0，行列式的i阶顺序主子式&gt;=0，i从1到n-1 📣 凸函数的充要条件：如果f(x)在开凸集S上具有二阶连续偏导数，且f(x)的海塞矩阵（二阶偏导的矩阵）在S上处处半正定，则f(x)为S上的凸函数。 🖌 酉矩阵：酉矩阵的共轭转置和它的逆矩阵相等。","link":"/2018/11/30/Learning-notes-2018-11/"},{"title":"C++容器和文件读写","text":"😋 C++容器（STL容器）👹 顺序容器 元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置（尾部、头部或中间某处）插入，元素就会位于什么位置。 name 特点 vector 可变长动态数组 vector 支持快速随机访问 deque 双端队列deque 支持push_front、pop_front、push_back、pop_back list 双端链表 只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快。 forward_list 单向链表 只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。 😹 顺序容器适配器 name 特点 底层 stack 后进先出（LIFO）栈 deque queue 先进先出（FIFO）队列 支持push_back、pop_front。 deque priority_queue 优先级队列 vector 💌 关联容器 关联容器内的元素是排序的。插入元素时，容器会按一定的排序规则将元素放到适当的位置上，因此插入元素时不能指定位置。默认情况下，关联容器中的元素是从小到大排序（或按关键字从小到大排序）的，而且用&lt;运算符比较元素或关键字大小。因为是排好序的，所以关联容器在查找时具有非常好的性能。 将关键字有序保存 特点 map 关联数组 保存关键字-值 multimap 关键字可重复的map set 关键字即是值，即只保存关键字的容器 multiset 关键字可重复的set 无序集合 特点 unordered_set 用哈希函数组织的set unordered_multiset 用哈希函数组织的set:关键字可重复 unordered_map 用哈希函数组织的map unordered_multimap 用哈希函数组织的map:关键字可重复 💚 文件读写操作1234// fstream::open / fstream::close#include &lt;fstream&gt; // std::fstreamvoid open(const char *filename, ios::openmode mode);void close(); 模式标志 描述 ios::app 追加模式。所有写入都追加到文件末尾。 ios::ate 文件打开后定位到文件末尾。 ios::in 打开文件用于读取。 ios::out 打开文件用于写入。 ios::trunc 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 #### 🗯 写入文件 在 C++ 编程中，我们使用流插入运算符( &lt;&lt; ) 向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 ofstream 或 fstream 对象，而不是 cout 对象。 👵 读取文件 在 C++ 编程中，我们使用流提取运算符( &gt;&gt; )从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 ifstream 或 fstream 对象，而不是 cin 对象。 123456789101112131415161718192021222324252627#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std; int main (){ char data[100]; // 以写模式打开文件 ofstream outfile; outfile.open(\"afile.dat\"); cin.getline(data, 100); // 向文件写入用户输入的数据 outfile &lt;&lt; data &lt;&lt; endl; // 关闭打开的文件 outfile.close(); //---------------------- // 以读模式打开文件 ifstream infile; infile.open(\"afile.dat\"); infile &gt;&gt; data; // 关闭打开的文件 infile.close(); return 0;} 逐行读取文件 123456789101112int main(){ ifstream fin; fin.open(\"word.txt\"); string str; while (!fin.eof()) { getline(fin, str); cout &lt;&lt; str&lt;&lt; endl; } fin.close();} 🤽‍ 以上。(づ●─●)づ 转载请注明：Duankong的博客 » 点击阅读原文","link":"/2019/10/30/C-容器和文件读写/"},{"title":"PAT note 1","text":"😈 Dijkstra算法 1111. Online Map (30)😻 描述Dijkstra算法解决的是非负权重有向图上的单源最短路径问题。 算法逻辑为维持一个结点集合S，集合中每个结点之间的最短路径已经被找到，重复从集合V-S中选择与源结点r之间最短路径估计最小的结点u加入到S，然后对所有从u出发的边检查r到u的距离加上该边的距离是否小于该边另一个结点原本的最短路径估计。 🙈 实现12345678910111213141516171819202122232425262728void Dijkstra(int u){ memset(vis,0,sizeof(vis)); for(int t=1;t&lt;=n;t++) { dis[t]=map[u][t];//初始化 } vis[u]=1; for(int t=1;t&lt;n;t++) { int minn=Inf,temp; for(int i=1;i&lt;=n;i++) { if(!vis[i]&amp;&amp;dis[i]&lt;minn) { minn=dis[i]; temp=i; } } vis[temp]=1; for(int i=1;i&lt;=n;i++) { if(vis[i]==0&amp;&amp;map[temp][i]+dis[temp]&lt;dis[i]) { dis[i]=map[temp][i]+dis[temp]; } } } 💕 拓扑排序 1146 Topological Order (25 分) 1234567891011121314151617181920bool jujle(vector&lt;int&gt; s){ fill(vis, vis + 1001, 0); for (int i = 0; i &lt; s.size(); i++) { if (vis[s[i]] == 1) { return false; } for (int j = 0; j &lt; node[s[i]].size(); j++)//判断每个父节点全被遍历过 { if(vis[node[s[i]][j]]==0) return false; } vis[s[i]] = 1; } return true;} 💥 红黑树 1135 Is It A Red-Black Tree (30 分)💙 定义R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。红黑树的特性:（1）每个节点或者是黑色，或者是红色。（2）根节点是黑色。（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]（4）如果一个节点是红色的，则它的子节点必须是黑色的。（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 注意：(01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。(02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。 ✊ 判断👨‍💻 规则4C++判断12345678910111213bool prop4(node *root){ if (root == NULL) return true; if (root-&gt;data &lt; 0) { if (root-&gt;left != NULL &amp;&amp; root-&gt;left-&gt;data &lt; 0) return false; if (root-&gt;right != NULL &amp;&amp; root-&gt;right-&gt;data &lt; 0) return false; } return prop4(root-&gt;left) &amp;&amp; prop4(root-&gt;right);} 👼 规则5C++判断1234567891011121314151617int getnum(node *root)//得到经过的黑节点{ if (root == NULL) return 0; int l = getnum(root-&gt;left); int r = getnum(root-&gt;right); return root-&gt;data &gt; 0 ? max(l, r) + 1 : max(l, r);}bool prop5(node* root){ if (root == NULL)return true; int l = getnum(root-&gt;left); int r = getnum(root-&gt;right); if (l != r) return false; return prop5(root-&gt;left) &amp;&amp; prop5(root-&gt;right);} 💆‍ Hashing 插入和查找: 1078 Hashing (25 分) 1145 Hashing - Average Search Time (25 分)🏊‍ 插入 Quadratic probing (with positive increments only) is used to solve the collisions. 12345678910for (int j = 0; j &lt;= msize; j++)//等于{ position = (key%msize + j * j) % msize;//主要 if (vis[position] == 0) { vis[position] = 1; find_ = true; break; }} 😞 查找123456789101112131415bool search(int n){ int position = n % msize; int cnt = 0; for (int i = 0; i &lt;=msize; i++) { position = (n%msize + i * i) % msize;//注意是等于n，和插入时一样 tot++; if (htable[position] == n)//找到了 return true; if (htable[position] == 0)//没有这个数 return false; } return false;} 🍹 以上。(づ●─●)づ 转载请注明：Duankong的博客 » 点击阅读原文","link":"/2019/12/03/PAT-note-1/"},{"title":"PCA(Principal Component Analysis) 主成分分析","text":"标签 : PCA 降维 🥃 PCA的实现一般有两种，一种是用特征值分解去实现的，一种是用奇异值分解去实现的。 🎯 特征值和奇异值🌌 如何理解矩阵特征值？ 🌅 奇异值分解（SVD） 🎨 主成分分析—PCA 正如字面上的意思，主成分分析，首先得找出所谓的”主成分”，并且表示它，然后才能分析。 一个n维数据集，要找所谓的”主成分”，不如说是找主成分所在的方向，也就是说找一个新的坐标系，然后把数据投影过去。 🍑 那么新的坐标系怎么找？ 对于PCA来说，认为一个随机信号最有用的信息体包含在方差里。自然而然，我们希望信号在方差最大的维度作为我们的”主成分”，方差小的维度的信号就可以看做是信息量小的或者不重要的数据，那么就可以丢弃。 假设m个n维随机信号$X=(x_1,x_2,…,x_m)$,存在一个坐标系$w^T$。(信号x各维度都减去了其均值) 对于一个一维向量来说，方差可以度量其包含的信息。对于一个矩阵，可以用协方差来表示： 那么容易得到信号$X$的协方差:$$ S=\\frac{1}{n}XX^T $$投影后方差:$$ S’=\\frac{1}{n} (w^TX)^2=\\frac{1}{n}w^TXX^Tw=w^T(\\frac{1}{n}XX^T)w=w^TSw $$ 要求方差S'最大，那么可以得到优化问题： $$ \\max_{w}w^TSw $$$$ s.t.||w||=1$$使用拉格朗日乘数法： $$L=w^TSw+\\lambda(1-w^Tw)$$ $$\\frac{\\partial L}{\\partial w}=2Sw-2\\lambda w$$易得:$$Sw=\\lambda w$$如果还没忘记什么叫做特征值的话，那么这个式子就可以告诉我们：求的坐标系$w$其实就是方差$S$的特征向量。 到这里，我们已经找到了新的坐标系$w$。 🍻 那么开始分析 第一步 自然是求出处理过后$X_{n\\times m}$协方差矩阵$S_{n\\times n}$; 第二步 求出协方差矩阵的特征值及对应的特征向量(特征值分解)，将特征向量按对应特征值大小从上到下按行排列成矩阵，取前$k$行组成矩阵$P_{k\\times n}$（舍去了$k-1$行到$n$行的数据达到压缩的目的）； 第三步 $Y_{k\\times m}=P_{k\\times n}X_{n\\times m}$，$Y_{k\\times m}$就是最终得到的降维的数据。 🍟奇异值呢？从开始到结束似乎都没有用到奇异值分解？ 考虑一个问题，在维度很低的时候，我们能轻松求出矩阵的协方差以及其特征值和特征向量。那么当维度很多的时候呢？ 可见协方差以及以及特征值分解时计算时间随着维度增加呈类似指数型的增长。此时，SVD就派上用场了：$$A_{m\\times n}=U_{m\\times m}\\Sigma_{m\\times n} V_{n\\times n}^{* } \\approx U_{m\\times k}\\Sigma_{k\\times k}V_{k\\times n}^{** }$$ 🍕 Disp: 上式中$V$的一颗*和两颗星**均表示$V$的共轭转置，一颗*的$V$表示$n\\times n$的酉矩阵。上述表示是因为都是一颗*的时候出现BUG，公式显示不了╮(╯▽╰)╭。 其中$U$是$m\\times m$的酉矩阵；$\\Sigma$是$m\\times n$非负实数对角矩阵。当前$k$行的奇异值之和奇异值总体之和的比值接近于1约等号成立。 和方阵的特征值分解对比：$$A_{n\\times n}=P_{n\\times n}\\land_{n\\times n}P_{n\\times n}^{-1}$$ 有一些SVD的实现算法可以不求先求出协方差矩阵$ X^{T}X$ ，也能求出我们的右奇异矩阵$V$。那么有： $$Y_{m\\times k}=U_{m\\times k}\\Sigma_{k\\times k}V_{k\\times n}^{* }V_{n\\times k}=U_{m\\times k}\\Sigma_{k\\times k}$$这样，我们就通过SVD(SVD对方阵一样适用)避免了暴力特征分解，得到了最终的降维数据$Y_{m\\times k}$。 这里用的是右奇异矩阵$V$，对维度进行了压缩。假设能不先求出协方差也能求出左奇异矩阵$U$，那么我们就可以左乘对样本进行压缩。那么怎么求呢？实际上只要把原始数据$X_{m\\times n}$转置一下得到$X’_ {n\\times m}$作为输入就好了(0.0)。 🎭 PCA小结1、PCA假设源信号间彼此非相关，认为主元之间彼此正交，样本呈高斯分布。 2、PCA认为数据内的信息存在方差之中，所以在寻求新的坐标系的时候实际上求的就是方差最大的方向，然后通过拉格朗日乘子法确定实际上新的坐标系其实就是方差(原始数据的方差)的特征向量。 3、特征值分解只能针对方阵，奇异值分解任意矩阵(包括方阵)都可以。实际上都是求协方差的特征向量作为新的坐标系，一个是$P_{k\\times n}$，一个是$V$。只不过奇异值的好处就是可以减少计算量直接求解矩阵$V$。 4、PCA适用于线性相关的维度，对于非线性的数据来说可以考虑用K-PCA也就是基于核函数的PCA。 水平有限，如有错误还请批评指正！ 以上。(づ●─●)づ 转载请注明：Duankong的博客 » 点击阅读原文","link":"/2018/11/15/PCA-Principal-Component-Analysis-主成分分析/"},{"title":"二叉搜索树Binary Search Tree (BST)","text":"🈚️ 二叉搜索树的定义 二叉搜索树是一种节点值之间具有一定数量级次序的二叉树，对于树中每个节点： 若其左子树存在，则其左子树中每个节点的值都不大于该节点值(左节点&lt;父节点)； 若其右子树存在，则其右子树中每个节点的值都不小于该节点值(右节点&gt;=父节点)。 左、右子树也分别为二叉搜索树。 🔠 二叉搜索树的特点 如果二叉排序树是平衡的，则n个节点的二叉排序树的高度为Log2n+1,其查找效率为O(Log2n)，近似于折半查找。如果二叉排序树完全不平衡，则其深度可达到n，查找效率为O(n)，退化为顺序查找。一般的，二叉排序树的查找性能在O(Log2n)到O(n)之间。因此，为了获得较好的查找性能，就要构造一棵平衡的二叉排序树。 ➰ 二叉搜索树的建立♻️ C++代码1234567891011121314151617181920212223242526272829303132node *build_bst(node * root, int num){ if (root == NULL) { root = new node; root-&gt;data = num; root-&gt;left = NULL; root-&gt;right = NULL; } else if (num &lt;= root-&gt;data) { root-&gt;left = build_bst(root-&gt;left, num); } else { root-&gt;right = build_bst(root-&gt;right, num); } return root;}int main(){ int n; cin &gt;&gt; n; node *root = NULL; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; kk; root = build_bst(root, kk); } return 0;} 🛐 查询操作 从根节点开始查找，待查找的值是否与根节点的值相同，若相同则返回True；否则，判断待寻找的值是否比根节点的值小，若是则进入根节点左子树进行查找，否则进入右子树进行查找。该操作使用递归实现。 12345678910111213void query(root, val){ '''二叉搜索树查询操作''' if (root == None) return False; if (root.val == val) return True; else if (val &lt; root.val) query(root.left, val); else if (val &gt; root.val) query(root.right, val);} 🚿 查找二叉搜索树中的最大（小值） （1）查找最小值：从根节点开始，沿着左子树一直往下，直到找到最后一个左子树节点，按照定义可知，该节点一定是该二叉搜索树中的最小值节点。 12345678int findMin(root){ '''查找二叉搜索树中最小值点''' if (root.left!=NULL) findMin(root.left) else return root.data} （2）查找最大值：从根节点开始，沿着右子树一直往下，直到找到最后一个右子树节点，按照定义可知，该节点一定是该二叉搜索树中的最大值节点。 12345678int findMax(root){ '''查找二叉搜索树中最大值点''' if (root.right!=NULL) findMin(root.right) else return root.data} 🐑 以上。(づ●─●)づ 转载请注明：Duankong的博客 » 点击阅读原文","link":"/2019/11/25/二叉搜索树Binary-Search-Tree-BST/"},{"title":"求三维图像的海森矩阵","text":"标签 : 三维图像 海森矩阵 二阶偏导数 高斯函数 👌 雅可比矩阵 在向量分析中，雅可比矩阵是一阶偏导数以一定方式排列成的矩阵, 其行列式称为雅可比行列式。 👀 海森矩阵 数学中，海森矩阵(Hessian matrix)是一个自变量为向量的实值函数的二阶偏导数组成的方块矩阵（假设其二阶偏导都存在）。 $$ H(f)=\\left[\\begin{matrix} \\frac{\\partial^2 f}{\\partial x^2_1} &amp; \\frac{\\partial^2 f}{\\partial x_1x_2} &amp; \\cdots &amp; \\frac{\\partial^2 f}{\\partial x_1x_n} \\ \\frac{\\partial^2 f}{\\partial x_2x_1} &amp; \\frac{\\partial^2 f}{\\partial x^2_2} &amp; \\cdots &amp; \\frac{\\partial^2 f}{\\partial x_2x_n} \\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ \\frac{\\partial^2 f}{\\partial x_nx_1} &amp; \\frac{\\partial^2 f}{\\partial x_n x_2} &amp; \\cdots &amp; \\frac{\\partial^2 f}{\\partial x^2_n} \\\\end{matrix}\\right] $$ 🙅 高斯求导 👚 前言通过上述公式可知，求海森矩阵的过程实际上就是求二阶偏导的过程。卷积中有一个重要的性质：卷积的微分特性—两个函数相卷积后的导数等于其中一个函数的导数与另一个函数的卷积 $$ \\frac{d}{dt}[f_{1}(t)\\ * f_{2}(t)]=\\frac{df_{1}(t)} {dt}\\ * f_2(t)= f_1(t)\\ * \\frac{df_2(t)}{dt} $$ 证明如下： $$\\frac{d}{dt}[f_1(t)\\ * f_2(t)]=\\frac{d}{dt}\\int ^{\\infty} _ {-\\infty} f_1(\\tau)\\ * f_2(t-\\tau)d\\tau= \\int ^{\\infty} _ {-\\infty} f_1(\\tau)\\ * \\frac{d}{dt}f_2(t-\\tau)d\\tau=f_1(t)\\ * \\frac{df_2(t)}{dt} $$ 同理可证：$$\\frac{d}{dt}[f_1(t)\\ * f_2(t)]=\\frac{d}{dt}\\int ^{\\infty}_ {-\\infty} f_1(\\tau)\\ * f_2(t-\\tau)d\\tau= \\int ^{\\infty}_ {-\\infty} \\frac{d}{dt}f_1(\\tau)\\ * f_2(t-\\tau)d\\tau=\\frac{df_1(t)}{dt}\\ * f_2(t) $$ 故上述微分特性得证。推广易得：$$\\frac{\\partial^2}{\\partial t^2}[f_1(t)\\ * f_2(t)]=\\frac{\\partial^2f_1(t)}{\\partial t^2}\\ * f_2(t)= f_1(t)\\ * \\frac{\\partial^2f_2(t)}{\\partial t^2}$$ ⛑ 推导 根据上式，令$f_1(t)$为高斯函数$G(x,y,z)=(\\frac{1}{\\sqrt{2\\pi}\\sigma})^3e^{-\\frac{x^2+y^2+z^2}{2\\sigma^2}}$，$f_2(t)$为三维图片$I(x,y,z)$，则有:$$\\frac{\\partial^2}{\\partial x^2}[G(x,y,z)\\ * I(x,y,z)]=\\frac{\\partial^2G(x,y,z)}{\\partial x^2}\\ * I(x,y,z)= G(x,y,z)\\ * \\frac{\\partial^2I(x,y,z)}{\\partial x^2}$$可知，只要求得了$\\frac{\\partial^2G(x,y,z)}{\\partial x^2}$,那么通过上式就可以得到$\\frac{\\partial^2I(x,y,z)}{\\partial x^2}$为图像$I$在$(x,y,z)$点的对$x$的二阶偏导。其他方向的二阶偏导同理可求。到这里，求图像的二阶偏导转换成了求高斯函数的二阶偏导。 跳过。。跳过。。一系列的求导过程((٩(//̀Д/́/)۶)) 得到以下高斯函数的二阶偏导：$$\\frac{\\partial^2G(x,y,z)}{\\partial x^2}=\\frac{1}{(\\sqrt{2\\pi}\\sigma)^3}\\frac{x^2-\\sigma^2}{\\sigma^4}e^{-\\frac{x^2+y^2+z^2}{2\\sigma^2}}=\\frac{x^2-\\sigma^2}{(\\sqrt{2\\pi})^3\\sigma^7}e^{-\\frac{x^2+y^2+z^2}{2\\sigma^2}}$$$$\\frac{\\partial^2G(x,y,z)}{\\partial x\\partial y}=\\frac{1}{(\\sqrt{2\\pi}\\sigma)^3}\\frac{xy}{\\sigma^4}e^{-\\frac{x^2+y^2+z^2}{2\\sigma^2}}=\\frac{xy}{(\\sqrt{2\\pi})^3\\sigma^7}e^{-\\frac{x^2+y^2+z^2}{2\\sigma^2}}$$同理易得高斯函数$G(x,y,z)$对$y^2,z^2,yx,xz,zx,yz,zy$等方向的偏导。可以发现：$$\\frac{\\partial^2G(x,y,z)}{\\partial x\\partial y}=\\frac{\\partial^2G(x,y,z)}{\\partial y\\partial x}$$$$\\frac{\\partial^2G(x,y,z)}{\\partial x\\partial z}=\\frac{\\partial^2G(x,y,z)}{\\partial z\\partial x}$$$$\\frac{\\partial^2G(x,y,z)}{\\partial y\\partial z}=\\frac{\\partial^2G(x,y,z)}{\\partial z\\partial y}$$至此，高斯函数所有的二阶偏导已经求得，然后利用matlab中的convn函数进行三维空间内的卷积(参数选择same保证结果和图像一致)，这也意味着黑森矩阵已经可以通过上述过程得到。 🐼 代码实现 123456789101112131415161718192021222324252627%% 求高斯函数的二阶偏导数%% num为高斯核的大小%% sigma为高斯函数的方差function [gau_xx,gau_yy,gau_zz,gau_xy,gau_xz,gau_yz]=gaus_creation_3D(num,sigma)gau_xx=[];gau_yy=[];gau_zz=[];%初始化矩阵gau_xy=[];gau_xz=[];gau_yz=[];%初始化矩阵for i=1:1:2*num+1 for j=1:1:2*num+1 for k=1:1:2*num+1 x=i-num-1;y=j-num-1;z=k-num-1; gau_xx(i,j,k)=1/power(sqrt(2*pi),3)*(-(sigma^2-x^2)/sigma^7)*exp(-(x^2+y^2+z^2)/2/sigma^2); gau_yy(i,j,k)=1/power(sqrt(2*pi),3)*(-(sigma^2-y^2)/sigma^7)*exp(-(x^2+y^2+z^2)/2/sigma^2); gau_zz(i,j,k)=1/power(sqrt(2*pi),3)*(-(sigma^2-z^2)/sigma^7)*exp(-(x^2+y^2+z^2)/2/sigma^2); gau_xy(i,j,k)=1/power(sqrt(2*pi),3)*(x*y/sigma^7)*exp(-(x^2+y^2+z^2)/2/sigma^2); gau_xz(i,j,k)=1/power(sqrt(2*pi),3)*(x*z/sigma^7)*exp(-(x^2+y^2+z^2)/2/sigma^2); gau_yz(i,j,k)=1/power(sqrt(2*pi),3)*(z*y/sigma^7)*exp(-(x^2+y^2+z^2)/2/sigma^2); end endendend 🐕 思考 关于最终的结果从$\\frac{\\partial^2}{\\partial x^2}[G(x,y,z) \\ * I(x,y,z)]=\\frac{\\partial^2G(x,y,z)}{\\partial x^2} \\ * I(x,y,z)= G(x,y,z)\\ * \\frac{\\partial^2I(x,y,z)}{\\partial x^2}$式中可知最后的结果其实是图像的二阶偏导和高斯函数的卷积，并不只是单纯的图像二阶偏导。高斯函数在图像处理中常用于去除高斯噪声，它具有良好的低通滤波效果，一般在检测边缘之前常用高斯卷积来移除图像一些细节以及噪声。所以事实上，这里的卷积不会影响图像整体的结构，而且一定程度上对图像进行了去噪使图像质量更好(当然不可否认的是损失了一些图像细节)，如果是利用海森矩阵进行三维图像的线性结构或是面结构的检测，那么一定程度的去噪以及平滑处理将可能得到更好的结果。 🐑 以上。(づ●─●)づ 转载请注明：Duankong的博客 » 点击阅读原文","link":"/2018/10/22/求三维图像的海森矩阵/"},{"title":"背包问题","text":"🏃 问题描述有n件物品，每件物品的重量为w[i]，价值为c[i]。现有一个重量为V的背包，问如何选取物品放入背包，使得背包内物品的总价值最大。其中每种物品只有1件 dp[i][j]表示前i件物品恰好装入容量为j的背包所能获得的最大价值 1、不放第i件物品，则 dp[i][j] = dp[i-1][j] 2、放第i件物品，那么问题转化为前i – 1件物品恰好装入容量j – w[i]的背包中所能获得的最大价值 dp[i-1][j-w[i]] + c[i] 3、递推方程dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+c[i]); 💇 通用解法1234567for(int i = 1; i &lt;= n; i++) { for(int j = 1, j &lt;= v; j++) if(j - w[i] &gt;= 0) dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + c[i]); else dp[i][j] = dp[i-1][j]; } 一维 1234for(int i = 1; i &lt;= n; i++) { for(int j = v; j &gt;= w[i]; j--) dp[v] = max(dp[v], dp[v-w[i]] + c[i]);} 🏄 实例 1068 Find More Coins (30 分) 题目大意：用n个硬币买价值为m的东西，输出使用方案，使得正好几个硬币加起来价值为m。从小到大排列，输出最小的那个排列方案 ⛹️‍ 背包问题求解01背包问题，因为要输出从小到大的排列，可以先把硬币面额从大到小排列，然后用bool类型的choice[i][j]数组dp[i][j]是否选取，如果选取了就令choice为true；然后进行01背包问题求解，如果最后求解的结果不是恰好等于所需要的价值的，就输出No Soultion，否则从choice[i][j]判断选取的情况，i从n到1表示从后往前看第i个物品的选取情况，j从m到0表示从容量m到0是否选取(j = j – w[i])，把选取情况压入arr数组中，最后输出arr数组 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int dp[10010];int w[10010];bool choice[10010][10010];int cmp1(int a, int b){return a &gt; b;}int main() { int n, m; scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;w[i]); sort(w + 1, w + n + 1, cmp1); for(int i = 1; i &lt;= n; i++) { for(int j = m; j &gt;= w[i]; j--) { if(dp[j] &lt;= dp[j-w[i]] + w[i]) {//当容量为j时，放进去可以得到更高价值 choice[i][j] = true;//flag dp[j] = dp[j-w[i]] + w[i]; } } } if(dp[m] != m) printf(\"No Solution\"); else { vector&lt;int&gt; arr; int v = m, index = n; while(v &gt; 0) { if(choice[index][v] == true) { arr.push_back(w[index]); v -= w[index];//减去找到的硬币 } index--;//找下一个indx } for(int i = 0; i &lt; arr.size(); i++) { if(i != 0) printf(\" \"); printf(\"%d\", arr[i]); } } return 0;} 🤹‍ 直接求最小的数列，通过ok判断是否找到最小。12345678910111213141516171819202122vector&lt;int&gt; coin;vector&lt;int&gt; temp, res;int ok = 0;void dfs(int nowk, int nowsum){ //show_res(temp); if (nowk &gt; n || nowsum &gt; m || ok == 1) return; if (nowsum == m) { ok = 1; res = temp; return; } for (int i = nowk; i &lt; n; i++) { temp.push_back(coin[i]); dfs(i + 1, nowsum + coin[i]); temp.erase(temp.end() - 1); }} 🤽‍ 以上。(づ●─●)づ 转载请注明：Duankong的博客 » 点击阅读原文","link":"/2019/12/02/背包问题/"},{"title":"PAT Note 2","text":"🤓 Queue 1056 Mice and Rice (25分)题目大意：np为老鼠的数量，ng为每组最多g个老鼠。先给出np个老鼠的重量，再给出老鼠的初始顺序（第i名的老鼠是第j号，j从0开始）。每ng个老鼠分为一组，对于每组老鼠，选出最重的那个，晋级下一轮比赛，然后依次再以np个老鼠一组分类，然后选出重量最大的。。。直到只剩下一只老鼠，排名为1.输出为老鼠的排名，这个排名是按照原输入老鼠的顺序输出的。 分析：设立结构体node表示老鼠，里面包括weight重量，index是按照排名后的顺序的老鼠的下标，index0是排名前老鼠的下标。rank是最终要输出的老鼠的排名。 先将所有的老鼠按照排名后的顺序依次放入队列中，对于队列中的每一个老鼠，按照分组后选择最大重量的比赛规则，将每次分组获得第一的老鼠放入队列尾部。此处有一点，如果当前剩下的老鼠可以分为group组，那么这一组里面没有晋级的老鼠排名就是group+1.此处解释一下： 因为对于共有group组的老鼠，每组晋级一个，也就是说最终这一轮能晋级的是group个老鼠，那么没有晋级的所有人就是group+1名，就像有4个人晋级下一轮，那么所有没晋级的这一轮就都是并列第5名。 group的计算方法是：如果当前轮次的人数正好可以被每组ng人的ng整除，那么就有人数/ng个组。如果不能被整除，就有剩下来的一些老鼠分为一组，就是人数/ng + 1组。（这是求得group的方法） cnt用来控制当前的组内第几个人，如果cnt能够被ng整除了说明已经是下一组了，就cnt = 0；否则cnt不断++，同时将最重的老鼠体重赋值给maxn，最重的老鼠的node赋值给maxnode。 最后将结果结构体w排序，按照先前保存的index0的顺序排序，因为题目要求是必须按照题目所给的输入顺序输出的，排序后即可按序输出。 🤠 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364struct node{ int weight, index, index0, rank;};bool cmp1(node a, node b) { return a.index0 &lt; b.index0;}int main(){ cin &gt;&gt; n &gt;&gt; g; mouse.resize(n); vector&lt;node&gt; w(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; mouse[i]; } for (int i = 0; i &lt; n; i++) { cin &gt;&gt; k; w[i].weight = mouse[k]; w[i].index = i; w[i].index0 = k; } //process queue&lt;node&gt; q; for (int i = 0; i &lt; n; i++) q.push(w[i]); while (!q.empty()) { int size = q.size(); if (size == 1) { node temp = q.front(); w[temp.index].rank = 1; break; } int group = size / g; if (size % g != 0) group += 1; node maxnode; int maxn = -1, cnt = 0; for (int i = 0; i &lt; size; i++) { node temp = q.front(); w[temp.index].rank = group + 1; q.pop(); cnt++; if (temp.weight &gt; maxn) { maxn = temp.weight; maxnode = temp; } if (cnt == g || i == size - 1) { cnt = 0; maxn = -1; q.push(maxnode); } } } sort(w.begin(), w.end(), cmp1); for (int i = 0; i &lt; n; i++) { if (i != 0) printf(\" \"); printf(\"%d\", w[i].rank); } return 0;} 💀 并查集 1118 Birds in Forest (25分)👿 主要函数😻 找到最终根节点1234567891011121314int unionsearch(int root) //查找根结点{ int son, tmp; son = root; while(root != pre[root]) //找到掌门 root = pre[root]; while(son != root) //修改不是掌门的人 { tmp = pre[son]; pre[son] = root; son = tmp; } return root; //掌门驾到~~} 💖 合并12345678void join(int root1, int root2) //虚竹和周芷若做朋友{ int x, y; x = unionsearch(root1);//我老大是玄慈 y = unionsearch(root2);//我老大是灭绝 if(x != y) pre[y] = x; //打一仗，谁赢就当对方老大} 💦 解题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455bool vis[maxx];//存在序号为i的鸟int cnt[maxx] = { 0 };//帮派int pre[maxx];//每个鸟的bossint main(){ for (int i = 0; i &lt; 10010; i++) { pre[i] = i; } cin &gt;&gt; n; int id, temp; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; k &gt;&gt; id;//认为第一只鸟为boss vis[id] = true; for (int t = 0; t &lt; k-1; t++) { cin &gt;&gt; temp; join(id, temp);//其他鸟的boss为第一只鸟 vis[temp] = true;//序号为temp的鸟存在 } } //process fill(cnt, cnt + maxx, 0); for (int i = 1; i &lt;= maxx; i++) { if (vis[i] == true)//第i只鸟存在 { int root = findf(i);//鸟boss,并修改不认识boss的鸟 cnt[root]++;//小弟+1 } } int numtree = 0, numbirds = 0; for (int i = 1; i &lt;= maxx; i++) { if (cnt[i] &gt; 0)//是个帮派 { numtree++;//帮派数+1 numbirds += cnt[i];//帮派成员+cnt[i] } } printf(\"%d %d\\n\", numtree, numbirds); cin &gt;&gt; k; int a, b; for (int i = 0; i &lt; k; i++) { cin &gt;&gt; a &gt;&gt; b; a = findf(a); b = findf(b); printf(\"%s\\n\", a == b ? \"Yes\" : \"No\"); } return 0;} 🤙 插入和归并排序 1089. Insert or Merge (25)👴 插入排序 🙋 归并排序 Merge sort 👨‍🏫 实现12345678910111213141516171819202122232425262728293031323334353637383940414243int main(){ cin &gt;&gt; n; a.resize(n); b.resize(n); for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; b[i]; //process int i, j; for (i = 0; i &lt; n&amp;&amp;b[i] &lt;= b[i + 1]; i++);//插入排序之前呈递增 for (j = i + 1; j &lt; n&amp;&amp;a[j] == b[j]; j++);//后面和未排序之前一样 if (j == n) { printf(\"Insertion Sort\\n\"); sort(a.begin(), a.begin() + i+2 ); } else { printf(\"Merge Sort\\n\"); int flag = 1, k = 1; while (flag) { flag = 0; for (int i = 0; i &lt; n; i++) { if (a[i] != b[i]) flag = 1; } k = 2 * k; for (i = 0; i &lt; n / k; i++) sort(a.begin() + i * k, a.begin() + (i + 1)*k); sort(a.begin() + n / k * k, a.end());//对不足k进行排序 } } for (j = 0; j &lt; n; j++) { if (j != 0) printf(\" \"); printf(\"%d\", a[j]); } printf(\"\\n\"); return 0;} 🤴 堆排序 1098 Insertion or Heap Sort (25)🎅 堆排序 步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。 步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。 👯‍ 实现 堆排序的特点是后面是从小到大的，前面的顺序不一定，又因为是从小到大排列，堆排序之前堆为大顶堆，前面未排序的序列的最大值为b[1]，那么就可以从n开始往前找， 1) 找第一个小于等于b[1]的数字b[p]（while(p &gt; 2 &amp;&amp; b[p] &gt;= b[1]) p–;)把它和第一个数字交换（swap(b[1],b[p]);) 2) 然后把数组b在1~p-1区间进行一次向下调整（downAdjust(b, 1, p -1);)向下调整，low和high是需要调整的区间，因为是大顶堆，就是不断比较当前结点和自己的孩子结点哪个大，如果孩子大就把孩子结点和自己交换，然后再不断调整直到到达区间的最大值不能再继续了为止. 12345678910111213141516171819202122232425262728293031323334353637383940414243void downAdjust(vector&lt;int&gt; &amp;b, int low, int high){ int i = 0, j = 2 * i+1; while (j&lt;=high){ if (j + 1 &lt;= high &amp;&amp; b[j] &lt; b[j+1]) j = j + 1; if (b[i] &gt;= b[j]) break; swap(b[i], b[j]); i = j; j = 2 * i+1;//调整换了的部分是否乱序了 }}int main(){ cin &gt;&gt; n; a.resize(n); b.resize(n); for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; b[i]; //process int i, j; for (i = 0; i &lt; n&amp;&amp;b[i] &lt;= b[i + 1]; i++); for (j = i + 1; j &lt; n&amp;&amp;a[j] == b[j]; j++); if (j == n){ printf(\"Insertion Sort\\n\"); sort(a.begin(), a.begin() + i + 2); } else{ printf(\"Heap Sort\\n\"); int p = n-1; while (p &gt; 1 &amp;&amp; b[p] &gt;= b[0]) p--; //printf(\"p is %d\\n\", p); swap(b[0], b[p]); downAdjust(b, 0, p - 1); a = b; } for (j = 0; j &lt; n; j++) { if (j != 0) printf(\" \"); printf(\"%d\", a[j]); } printf(\"\\n\"); return 0;} 🐑 以上。(づ●─●)づ 转载请注明：Duankong的博客 » 点击阅读原文","link":"/2019/12/08/PAT-Note-2/"}],"tags":[{"name":"变量类型","slug":"变量类型","link":"/tags/变量类型/"},{"name":"常量","slug":"常量","link":"/tags/常量/"},{"name":"字符串","slug":"字符串","link":"/tags/字符串/"},{"name":"指针","slug":"指针","link":"/tags/指针/"},{"name":"先序遍历","slug":"先序遍历","link":"/tags/先序遍历/"},{"name":"中序遍历","slug":"中序遍历","link":"/tags/中序遍历/"},{"name":"后序遍历","slug":"后序遍历","link":"/tags/后序遍历/"},{"name":"深度遍历","slug":"深度遍历","link":"/tags/深度遍历/"},{"name":"广度(层次)遍历","slug":"广度-层次-遍历","link":"/tags/广度-层次-遍历/"},{"name":"树状数组","slug":"树状数组","link":"/tags/树状数组/"},{"name":"Matlab","slug":"Matlab","link":"/tags/Matlab/"},{"name":"Bigtiff","slug":"Bigtiff","link":"/tags/Bigtiff/"},{"name":"梯度散度和旋度","slug":"梯度散度和旋度","link":"/tags/梯度散度和旋度/"},{"name":"拉格朗日乘子","slug":"拉格朗日乘子","link":"/tags/拉格朗日乘子/"},{"name":"KKT","slug":"KKT","link":"/tags/KKT/"},{"name":"凸函数，正交和投影","slug":"凸函数，正交和投影","link":"/tags/凸函数，正交和投影/"},{"name":"病毒标记","slug":"病毒标记","link":"/tags/病毒标记/"},{"name":"无偏估计","slug":"无偏估计","link":"/tags/无偏估计/"},{"name":"朴素贝叶斯算法","slug":"朴素贝叶斯算法","link":"/tags/朴素贝叶斯算法/"},{"name":"容器","slug":"容器","link":"/tags/容器/"},{"name":"文件读写","slug":"文件读写","link":"/tags/文件读写/"},{"name":"红黑树","slug":"红黑树","link":"/tags/红黑树/"},{"name":"hashing查找","slug":"hashing查找","link":"/tags/hashing查找/"},{"name":"PAT","slug":"PAT","link":"/tags/PAT/"},{"name":"Dijkstra","slug":"Dijkstra","link":"/tags/Dijkstra/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/拓扑排序/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"PCA降维","slug":"PCA降维","link":"/tags/PCA降维/"},{"name":"二叉搜索树","slug":"二叉搜索树","link":"/tags/二叉搜索树/"},{"name":"BST","slug":"BST","link":"/tags/BST/"},{"name":"海森矩阵","slug":"海森矩阵","link":"/tags/海森矩阵/"},{"name":"三维图像","slug":"三维图像","link":"/tags/三维图像/"},{"name":"二阶偏导数","slug":"二阶偏导数","link":"/tags/二阶偏导数/"},{"name":"高斯函数","slug":"高斯函数","link":"/tags/高斯函数/"},{"name":"01背包问题","slug":"01背包问题","link":"/tags/01背包问题/"},{"name":"动态规划","slug":"动态规划","link":"/tags/动态规划/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"并查集","slug":"并查集","link":"/tags/并查集/"},{"name":"插入排序","slug":"插入排序","link":"/tags/插入排序/"},{"name":"归并排序","slug":"归并排序","link":"/tags/归并排序/"},{"name":"堆排序","slug":"堆排序","link":"/tags/堆排序/"}],"categories":[{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"Learning","slug":"Learning","link":"/categories/Learning/"},{"name":"Learning Note","slug":"Learning-Note","link":"/categories/Learning-Note/"},{"name":"Basic knowledge","slug":"C/Basic-knowledge","link":"/categories/C/Basic-knowledge/"},{"name":"Algorithm","slug":"C/Algorithm","link":"/categories/C/Algorithm/"},{"name":"PAT Note","slug":"C/PAT-Note","link":"/categories/C/PAT-Note/"},{"name":"Dimensionality-Reduction","slug":"Learning/Dimensionality-Reduction","link":"/categories/Learning/Dimensionality-Reduction/"},{"name":"Matlab","slug":"Learning/Matlab","link":"/categories/Learning/Matlab/"},{"name":"Feature-Extraction","slug":"Learning/Feature-Extraction","link":"/categories/Learning/Feature-Extraction/"}]}